uber coding challenges:
departure times

create a web app that gives real-time departure time for public transportation
(use freely available public api). the app should geolocalize the user. here are
some examples of freely available data:
- 511 (san francisco)
- nextbus (san francisco)
- sf movies

create a web app that shows on a map where movies have been filmed in san
francisco. the user should be able to filter the view using autocompletion
search.
- the data is available on datasf: film locations.

bicycle parking: create a web app providing directions to the nearest bicycle parking.
- the data is available on datasf: bicycle parking

food trucks: create a web app that tells the user what types of food trucks
might be found near a specific location. the main interface should be a map.

- the data is available on datasf: food trucks

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

the first component will continuously generate trip data, issuing messages for
the following events:

 - trip begin (data: trip id, latitude, longitude)
 - roughly once per second during a “trip” (data: trip id, latitude, longitude)
 - trip end (data: trip id, latitude, longitude, dollar amount of fare)

the second component will consume these events, store them in memory, and expose
an interface for querying the data thusly stored. the queries we’d like to be
able to answer are:

 - how many trips passed through a given geo-rect (defined by four lat/long pairs).
 - how many trips started or stopped within a given geo-rect, and the sum of their fares.
 - how many trips were occurring at a given point in time.

the two components can talk to each other however you see fit.

some bounding conditions:
 - assume a system with up to 500 concurrent trips at any given time.
 - assume further that we require interactive query times.

the purpose of this exercise is twofold. we’re interested in code style -
clarity, structure, etc.  we’re also interested in how you approach the
algorithmic issue of high insert volume with real- time query requirements. you
can use whichever libraries you like, but keep in mind that we’re interested in
your coding chops and this is an opportunity to show them off. use good
judgement.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

producer: javasript component in web page that simply loops and creates these
events.  one thread per trip, can javaascript do multiple threads?

it would also be cool if we can pull data from twitter or fb.
- use celery to do this, with the redis backend? (why redis and mongodb)

consumer: python/django backend that stores data and query web page that pulls
that data out and plots on map or provides a graph (using d3js).

- webapp: take a trip and provides muni or bike alternative.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

to mitigate high insert: multiple indexes

1) trip ID object: indexed by trip ID: gives queues containing trips

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

hmm, ok, so we can use rabbitmq msg queues, and have the threads of each
producer send data to a exchange.  the question is, do we need locking around
the queue?  on the receive end, we can have a thread pool handling the load,
which we'll have to estimate to the time needed to process a request.  to
process a request:

 start

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

There's no way for the TripProcessor to really stop unless it's start
call is run on another thread.

ok...so Ricardo says I should try celery instead, which runs on top of rmq (not
pika).

ok...so celery has these tasks per app/method (TripProcessor) which are executed by the caller
(the TripGenerator).  So let's see how this all fits:

Trip() -> calls these tasks:
TripBegin(id, lat, long)
TripUpdate(id, lat, long)
TripEnd(id, lat, long, fare)

Each of these has a latitude/longitude to it, so we can do:

num = NumTripsIntersect(bl, tr)
num = NumTripsStarted(bl, tr)
(num, fare) = NumTripsStopped(bl, tr)
num = NumTripsAtTime(t0)

for each task then, we do:
1) check which queue it needs to be in.

grid of queues, let's say we have 100 queues, so we split it up 10 x 10.
-90:90: -90:-81, -80:-71,..., -10:-1, 0:9, 10:19
-180:180

What data is in each location queue?
  - TripStart: time, tripID
  - TripUpdate: time, tripID
  - TripEnd: time, tripID, fare

We want three queues because for a query for all the start/ends, we don't want
to have to check the trips for those tripIDs in the middle of the box.

trip queue: ID:{locations, fare}

IMPLEMENTATION:

NumTripsIntersect()
  - get intersecting queues, sum up total of all inclusive queues.

NumTripsStarted(bl, tr)
  - get intersecting queues, sum up total of all queue.tripsStarted (Q[lat][long][start])

  trips started and fare:
   - find region queues
   - sum num q[x][y][start]
   - get list of trip ids
   - for all trip ids, get sum of fare.

NumTripsEnded(bl, tr)
  - get intersecting queues, sum up total of all Q[lat][long][end]

NumTripsAtTime(t):
  - ???

Insert: O(c), whre c is the number of queues it belongs to:

1) insert into [start,update,end],
   insert into trip queue?
   ? time?

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

worker:
$ celery worker --app=tripgrid -l info

generator
$ python
>>> from tripgrid.TripTasks import *
>>> f = TripBegin.delay(1, 3, 4)

python
>>> import tripgrid.simulator
>>> tripgrid.simulator.main()

nice, it works so far...got some logging out on the worker end...
now to see if we need locking when we insert into our data...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

another way to do this would be to have each task be a grid queue and have
each message be:
Message Type:(Message Data)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

wait...let's so we define a block of (5,5) (25,25), and let's say we have block on every 10


40-49  -    -     -     -     -
30-39  -    -     -     -     -
20-29  -    -     -     -     -
10-19  -    -     -     -     -
  0-9  -    -     -     -     -
      0-9 10-19 20-29 30-39 40-49

how do we split a queue?  e.g. there will be some tripIDs in a queue
that should not be counted, so how do we remove those from the count?

within a queue, we would have to still go through X number of tripIDs, but
this is still better than brute force...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

for now, we'll just have one list in each tripqueue.  dunno what we'd do with time..

This is what we had before
        if "locations" not in self.gridQueue[x][y][QUEUE_BEGIN]:
            self.gridQueue[x][y][QUEUE_BEGIN] = {'locations':[]}
        self.gridQueue[x][y][QUEUE_BEGIN]['locations'].append(tripID)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

oy...I think I need some locking or something...

[2013-12-11 01:36:23,921: WARNING/Worker-4] TripBegin 1: -16,-178
[2013-12-11 01:36:23,921: WARNING/Worker-2] TripBegin 2: -5,45
[2013-12-11 01:36:23,922: WARNING/Worker-4] Added trip ID 1 to tripQueue: [1]
[2013-12-11 01:36:23,923: WARNING/Worker-2] Added trip ID 2 to tripQueue: [2]
[2013-12-11 01:36:23,921: WARNING/Worker-3] TripBegin 0: -23,159
[2013-12-11 01:36:23,923: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[e84a21fe-f38b-4e6c-b1e5-05396d693476]
[2013-12-11 01:36:23,923: WARNING/Worker-3] Added trip ID 0 to tripQueue: [0]
[2013-12-11 01:36:23,931: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[95b437d4-b025-4e17-ae73-90f3010738fc]
[2013-12-11 01:36:23,934: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[edc29329-bddf-41ef-88bf-80015afb113c]
[2013-12-11 01:36:23,942: INFO/MainProcess] Received task: tripgrid.TripTasks.TripEnd[19af066e-dd20-46f2-a185-b218dd75fc24]
[2013-12-11 01:36:23,984: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[b4d26f82-befb-4015-b18b-474764789384] succeeded in 0.0634945890051s: None
[2013-12-11 01:36:23,993: WARNING/Worker-2] TripBegin 3: -42,164
[2013-12-11 01:36:23,993: WARNING/Worker-2] Added trip ID 3 to tripQueue: [2, 3]
[2013-12-11 01:36:23,994: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[d7bf548a-ff4a-481e-8f68-b42126f97440] succeeded in 0.0730876550078s: None
[2013-12-11 01:36:23,995: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[5e429547-7bd8-436f-8adf-5773b04f73bf] succeeded in 0.0741183749633s: None
[2013-12-11 01:36:23,999: WARNING/Worker-3] TripBegin 5: -75,-166
[2013-12-11 01:36:23,999: WARNING/Worker-3] Added trip ID 5 to tripQueue: [0, 5]
[2013-12-11 01:36:24,000: WARNING/Worker-1] TripEnd 5: -78,-164 = $5
[2013-12-11 01:36:24,025: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[edc29329-bddf-41ef-88bf-80015afb113c] succeeded in 0.0267114689923s: None
[2013-12-11 01:36:24,030: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[e84a21fe-f38b-4e6c-b1e5-05396d693476] succeeded in 0.0368390340009s: None
[2013-12-11 01:36:24,029: WARNING/Worker-2] TripBegin 4: 65,180
[2013-12-11 01:36:24,030: WARNING/Worker-2] Added trip ID 4 to tripQueue: [2, 3, 4]
[2013-12-11 01:36:24,053: ERROR/MainProcess] Task tripgrid.TripTasks.TripEnd[19af066e-dd20-46f2-a185-b218dd75fc24] raised unexpected: Exception('Trip ended for unknown tripID', 5)
