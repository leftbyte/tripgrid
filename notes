uber coding challenges:
departure times

create a web app that gives real-time departure time for public transportation
(use freely available public api). the app should geolocalize the user. here are
some examples of freely available data:
- 511 (san francisco)
- nextbus (san francisco)
- sf movies

create a web app that shows on a map where movies have been filmed in san
francisco. the user should be able to filter the view using autocompletion
search.
- the data is available on datasf: film locations.

bicycle parking: create a web app providing directions to the nearest bicycle parking.
- the data is available on datasf: bicycle parking

food trucks: create a web app that tells the user what types of food trucks
might be found near a specific location. the main interface should be a map.

- the data is available on datasf: food trucks

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

the first component will continuously generate trip data, issuing messages for
the following events:

 - trip begin (data: trip id, latitude, longitude)
 - roughly once per second during a “trip” (data: trip id, latitude, longitude)
 - trip end (data: trip id, latitude, longitude, dollar amount of fare)

the second component will consume these events, store them in memory, and expose
an interface for querying the data thusly stored. the queries we’d like to be
able to answer are:

 - how many trips passed through a given geo-rect (defined by four lat/long pairs).
 - how many trips started or stopped within a given geo-rect, and the sum of their fares.
 - how many trips were occurring at a given point in time.

the two components can talk to each other however you see fit.

some bounding conditions:
 - assume a system with up to 500 concurrent trips at any given time.
 - assume further that we require interactive query times.

the purpose of this exercise is twofold. we’re interested in code style -
clarity, structure, etc.  we’re also interested in how you approach the
algorithmic issue of high insert volume with real- time query requirements. you
can use whichever libraries you like, but keep in mind that we’re interested in
your coding chops and this is an opportunity to show them off. use good
judgement.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

producer: javasript component in web page that simply loops and creates these
events.  one thread per trip, can javaascript do multiple threads?

it would also be cool if we can pull data from twitter or fb.
- use celery to do this, with the redis backend? (why redis and mongodb)

consumer: python/django backend that stores data and query web page that pulls
that data out and plots on map or provides a graph (using d3js).

- webapp: take a trip and provides muni or bike alternative.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

to mitigate high insert: multiple indexes

1) trip ID object: indexed by trip ID: gives queues containing trips

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

hmm, ok, so we can use rabbitmq msg queues, and have the threads of each
producer send data to a exchange.  the question is, do we need locking around
the queue?  on the receive end, we can have a thread pool handling the load,
which we'll have to estimate to the time needed to process a request.

There's no way for the TripProcessor to really stop unless it's start
call is run on another thread.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

ok...so Ricardo says I should try celery instead, which runs on top of rmq (not
pika).

ok...so celery has these tasks per app/method (TripProcessor) which are executed by the caller
(the TripGenerator).  So let's see how this all fits:

Trip() -> calls these tasks:
TripBegin(id, lat, long)
TripUpdate(id, lat, long)
TripEnd(id, lat, long, fare)

Each of these has a latitude/longitude to it, so we can do:

num = NumTripsIntersect(bl, tr)
num = NumTripsStarted(bl, tr)
(num, fare) = NumTripsStopped(bl, tr)
num = NumTripsAtTime(t0)

for each task then, we do:
1) check which queue it needs to be in.

grid of queues, let's say we have 100 queues, so we split it up 10 x 10.
-90:90: -90:-81, -80:-71,..., -10:-1, 0:9, 10:19
-180:180

What data is in each location queue?
  - TripStart: time, tripID
  - TripUpdate: time, tripID
  - TripEnd: time, tripID, fare

We want three queues because for a query for all the start/ends, we don't want
to have to check the trips for those tripIDs in the middle of the box.

trip queue: ID:{locations, fare}

IMPLEMENTATION:

NumTripsIntersect()
  - get intersecting queues, sum up total of all inclusive queues.

NumTripsStarted(bl, tr)
  - get intersecting queues, sum up total of all queue.tripsStarted (Q[lat][long][start])

  trips started and fare:
   - find region queues
   - sum num q[x][y][start]
   - get list of trip ids
   - for all trip ids, get sum of fare.

NumTripsEnded(bl, tr)
  - get intersecting queues, sum up total of all Q[lat][long][end]

NumTripsAtTime(t):
  - ???

Insert: O(c), whre c is the number of queues it belongs to:

1) insert into [start,update,end],
   insert into trip queue?
   ? time?

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

worker:
$ celery worker --app=tripgrid -l info

generator
$ python
>>> from tripgrid.TripTasks import *
>>> f = TripBegin.delay(1, 3, 4)

python
>>> import tripgrid.simulator
>>> tripgrid.simulator.main()

nice, it works so far...got some logging out on the worker end...
now to see if we need locking when we insert into our data...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

another way to do this would be to have each task be a grid queue and have
each message be:
Message Type:(Message Data)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

wait...let's so we define a block of (5,5) (25,25), and let's say we have block on every 10


40-49  -    -     -     -     -
30-39  -    -     -     -     -
20-29  -    -     -     -     -
10-19  -    -     -     -     -
  0-9  -    -     -     -     -
      0-9 10-19 20-29 30-39 40-49

how do we split a queue?  e.g. there will be some tripIDs in a queue
that should not be counted, so how do we remove those from the count?

within a queue, we would have to still go through X number of tripIDs, but
this is still better than brute force...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

for now, we'll just have one list in each tripqueue.  dunno what we'd do with time..

This is what we had before
        if "locations" not in self.gridQueue[x][y][QUEUE_BEGIN]:
            self.gridQueue[x][y][QUEUE_BEGIN] = {'locations':[]}
        self.gridQueue[x][y][QUEUE_BEGIN]['locations'].append(tripID)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

oy...I think I need some locking or something...

[2013-12-11 01:36:23,921: WARNING/Worker-4] TripBegin 1: -16,-178
[2013-12-11 01:36:23,921: WARNING/Worker-2] TripBegin 2: -5,45
[2013-12-11 01:36:23,922: WARNING/Worker-4] Added trip ID 1 to tripQueue: [1]
[2013-12-11 01:36:23,923: WARNING/Worker-2] Added trip ID 2 to tripQueue: [2]
[2013-12-11 01:36:23,921: WARNING/Worker-3] TripBegin 0: -23,159
[2013-12-11 01:36:23,923: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[e84a21fe-f38b-4e6c-b1e5-05396d693476]
[2013-12-11 01:36:23,923: WARNING/Worker-3] Added trip ID 0 to tripQueue: [0]
[2013-12-11 01:36:23,931: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[95b437d4-b025-4e17-ae73-90f3010738fc]
[2013-12-11 01:36:23,934: INFO/MainProcess] Received task: tripgrid.TripTasks.TripBegin[edc29329-bddf-41ef-88bf-80015afb113c]
[2013-12-11 01:36:23,942: INFO/MainProcess] Received task: tripgrid.TripTasks.TripEnd[19af066e-dd20-46f2-a185-b218dd75fc24]
[2013-12-11 01:36:23,984: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[b4d26f82-befb-4015-b18b-474764789384] succeeded in 0.0634945890051s: None
[2013-12-11 01:36:23,993: WARNING/Worker-2] TripBegin 3: -42,164
[2013-12-11 01:36:23,993: WARNING/Worker-2] Added trip ID 3 to tripQueue: [2, 3]
[2013-12-11 01:36:23,994: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[d7bf548a-ff4a-481e-8f68-b42126f97440] succeeded in 0.0730876550078s: None
[2013-12-11 01:36:23,995: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[5e429547-7bd8-436f-8adf-5773b04f73bf] succeeded in 0.0741183749633s: None
[2013-12-11 01:36:23,999: WARNING/Worker-3] TripBegin 5: -75,-166
[2013-12-11 01:36:23,999: WARNING/Worker-3] Added trip ID 5 to tripQueue: [0, 5]
[2013-12-11 01:36:24,000: WARNING/Worker-1] TripEnd 5: -78,-164 = $5
[2013-12-11 01:36:24,025: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[edc29329-bddf-41ef-88bf-80015afb113c] succeeded in 0.0267114689923s: None
[2013-12-11 01:36:24,030: INFO/MainProcess] Task tripgrid.TripTasks.TripBegin[e84a21fe-f38b-4e6c-b1e5-05396d693476] succeeded in 0.0368390340009s: None
[2013-12-11 01:36:24,029: WARNING/Worker-2] TripBegin 4: 65,180
[2013-12-11 01:36:24,030: WARNING/Worker-2] Added trip ID 4 to tripQueue: [2, 3, 4]
[2013-12-11 01:36:24,053: ERROR/MainProcess] Task tripgrid.TripTasks.TripEnd[19af066e-dd20-46f2-a185-b218dd75fc24] raised unexpected: Exception('Trip ended for unknown tripID', 5)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

looked into: http://loose-bits.com/2010/10/distributed-task-locking-in-celery.html

and they're talking about a real distributed system across many nodes.  This
mutex shit should work...

- - - - - - - - - - - - - - -
Thu Dec 12 21:51:51 PST 2013
- - - - - - - - - - - - - - -

ok, so lets try to put the mutex in the TripTasks rather than the object.

fuck, looking at what the other proj does, there's no object on the backend.

so I think each tasks gets invoked with its own context, hence whenever a task
is invoked by a call, it grabs the currenet state of the object and runs within
that object's current state.

the other way to do this is to try to make each of those tasks idempotent.
possibly, after enough inserts, the grid will be filled out?

so...now, the order in which events are added arent' sequential...

- the other thing to try is to see if there's a notion of a single worker per
  thread.  This way, every time an update comes from a thread, that particular
  worker is used so that at least the updates from a particular trip are
  serialzed.

yeah...we're going to have to try to serialize this shit or try a different
approach.  data is all fucked at the end...

so...I think the problem with our approach is that the TripGrid really needs
to live in a single process, rather than in TripTasks.py.

we have:

  Threads                      celery
Trip.thread1 -\           /--> Task1 -> tripGrid.dosomething
Trip.thread2 -- rabbitmq ----> Task2 -> tripGrid.dosomethingelse
Trip.thread3 -/           \--> Task3 -> tripGrid.dosomething

so...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

alright, so since our TripGrid is a poor man's implementation of a database,
we'll just have to use one.  let's try redis, which is a good in memory nosql
key/value store.  so here's the flow:

thread -> task -> [celery . [rabbitmq] . celery] -> redis
query -> redis -> result

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

so redis has:
key:value: set/get a value.  increment, rem
list: lpush/rpush/lpop/rpop/lrange
set: sadd,sunion, etc
ordered set: zadd, etc

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

so in tripgrid, here's what we have:

10 x 10 grid with 3 queue types
  - BEGIN: tripIDs
  - END: fare, tripIDs
  - ALL: tripIDs

  -> tripGrid:X:Y:ALL      = sortet set {trip ID : time}
  -> tripGrid:X:Y:BEGIN    = sortet set {trip ID : time}
  -> tripGrid:X:Y:END      = sortet set {trip ID : time}
  -> tripGrid:X:Y:END.fare = total fare

tripQueue[ID] = fare, (locations,)
  -> tripQueue:ID:fare = fare
  -> tripQueue:ID:locations = sorted set {location: time}

time should be time.time, not human readable, so that it's sortable.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

so...how do we query this shit?  how do we know what tripIDs are valid?

tripQueue:ID:location = {location, time}
tripQueue:ID:fare = fare
tripGrid:X:Y:ALL = {ID, time}
tripGrid:X:Y:BEGIN = {ID, time}
tripGrid:X:Y:END = {ID, time}
tripGrid:X:Y:END:fare = fare

'keys *' works

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

hmm, this kinda what we want to query:

http://engineering.getglue.com/post/46520116130/fast-range-queries-with-redis

- Useful for performing range queries on datasets too large to be efficiently
  queried in other systems in an ad-hoc manner;
- O(log(N)) read and write times, and read can be executed in a single Redis
  command;
- O(N) storage space for a full tree;
- Any totally-ordered dataset can be usefully stored and queried.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

http://redis.io/commands/keys

  WARNING: consider KEYS as a command that should only be used in production
  environments with extreme care. It may ruin performance when it is executed
  against large databases. This command is intended for debugging and special
  operations, such as changing your keyspace layout. Don't use KEYS in your
  regular application code. If you're looking for a way to find keys in a subset
  of your keyspace, consider using sets.h

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

ok, so the class thing for the TripGrid.py just didn't work out.

Tried app.task(filter=task_method), but we were getting some weird pickle
serialization error when invoking the task:

  Exception Value: Can't pickle <type 'function'>: attribute lookup __builtin__.function failed

taking it out of the class shite seemed to help.

so...it looks like we have data in our DB, and it looks...normal!  Now to write the query.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

https://github.com/leftbyte/tripgrid.git

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

ok, now to write these queries and try out 500 concurrent trips.

let's see if this shit is going to work out!

r.zrange("tripQueue:5:locations", 0, -1)
['(52, 53)', '(52, 57)', '(49, 52)', '(56, 57)', '(55, 58)', '(50, 54)', '(51, 54)', '(57, 52)', '(53, 48)', '(49, 54)']

0 50
  0      1       2       3       4
[0 9] [10 19] [20 29] [30 39] [40 49]

('trip data: 2 $6 [(17, -148), (13, -150)]',)
('trip data: 6 $5 [(-47, -170), (-52, -170)]',)
('trip data: 12 $3 [(-84, 138), (-85, 140)]',)
('trip data: 16 $8 [(-71, 66), (-67, 62)]',)
('trip data: 13 $12 [(61, 88), (56, 85), (60, 85)]',)
('trip data: 0 $18 [(-54, -74), (-51, -77), (-49, -78), (-52, -72)]',)
('trip data: 10 $17 [(40, -153), (38, -155), (42, -156), (40, -150)]',)
('trip data: 18 $22 [(55, 27), (55, 23), (60, 25), (53, 29)]',)
('trip data: 17 $20 [(20, -97), (24, -96), (22, -99), (19, -98), (21, -94)]',)
('trip data: 7 $35 [(74, -38), (72, -35), (78, -43), (79, -37), (70, -37)]',)
('trip data: 15 $44 [(-56, -73), (-58, -68), (-59, -76), (-61, -69), (-58, -73), (-52, -68), (-52, -69)]',)
('trip data: 1 $42 [(17, -4), (14, -8), (14, -1), (22, -2), (16, -6), (18, -5), (18, -7), (14, -7)]',)
('trip data: 3 $43 [(-33, 122), (-33, 121), (-36, 121), (-31, 126), (-32, 119), (-36, 120), (-36, 124), (-28, 120)]',)
('trip data: 4 $61 [(81, -150), (85, -155), (78, -150), (81, -146), (79, -147), (76, -155), (76, -145), (81, -149)]',)
('trip data: 19 $77 [(16, 21), (13, 25), (17, 16), (16, 24), (11, 26), (21, 17), (17, 25), (12, 20)]',)
('trip data: 11 $32 [(-37, -10), (-40, -11), (-38, -10), (-38, -9), (-37, -5), (-40, -11), (-41, -10), (-38, -5)]',)
('trip data: 8 $42 [(-78, -39), (-79, -40), (-80, -40), (-81, -41), (-78, -34), (-79, -43), (-81, -34), (-76, -35)]',)
('trip data: 14 $65 [(-73, -85), (-77, -80), (-77, -90), (-72, -82), (-72, -88), (-78, -85), (-77, -82), (-70, -84), (-73, -86)]',)
('trip data: 9 $51 [(-13, -30), (-11, -31), (-15, -26), (-8, -28), (-15, -30), (-11, -32), (-8, -31), (-9, -28), (-14, -26)]',)
('trip data: 5 $77 [(-21, -142), (-26, -143), (-20, -141), (-24, -141), (-16, -146), (-19, -137), (-18, -139), (-25, -138), (-18, -146), (-22, -142)]',)

python tripgrid/TripQuery.py -a --bl -90,-180 --tr 90,180
Trips:  32

interesting...we need to prune the repeats in a particular trip.

ahh, the problem is that if a trip goes from one grid queue to another, all within
the bounding box, it's counted twice.

pythonic remove duplicates
t = [1, 2, 3, 1, 2, 5, 6, 7, 8]
>>> t
[1, 2, 3, 1, 2, 5, 6, 7, 8]
>>> list(set(t))
[1, 2, 3, 5, 6, 7, 8]
>>> s = [1, 2, 3]
>>> list(set(t) - set(s))
[8, 5, 6, 7]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

('trip data: 0 $4 [(-6, 136), (-4, 138)]',)
('trip data: 8 $10 [(65, 9), (70, 14)]',)
('trip data: 11 $6 [(65, 76), (70, 77)]',)
('trip data: 16 $6 [(9, 67), (6, 70)]',)
('trip data: 1 $8 [(26, -10), (26, -13), (29, -15)]',)
('trip data: 9 $7 [(-19, -68), (-19, -72), (-17, -71)]',)
('trip data: 4 $10 [(5, -97), (7, -97), (5, -96), (10, -96)]',)
('trip data: 5 $15 [(6, -155), (10, -155), (11, -160), (7, -159)]',)
('trip data: 12 $18 [(-74, -63), (-75, -66), (-79, -64), (-73, -62)]',)
('trip data: 15 $25 [(84, 102), (84, 97), (84, 98), (81, 97), (86, 104), (87, 102)]',)
('trip data: 2 $74 [(-63, -46), (-59, -48), (-68, -46), (-58, -50), (-65, -42), (-58, -51), (-60, -41)]',)
('trip data: 6 $53 [(-3, 107), (-8, 111), (2, 110), (-8, 106), (-7, 107), (-1, 102), (-5, 104)]',)
('trip data: 7 $46 [(-84, -105), (-81, -102), (-89, -106), (-82, -110), (-80, -107), (-80, -108), (-87, -108), (-85, -110)]',)
('trip data: 10 $45 [(56, 74), (56, 69), (57, 73), (61, 77), (51, 78), (56, 77), (56, 78), (55, 70)]',)
('trip data: 13 $55 [(80, 131), (85, 135), (79, 130), (78, 132), (81, 135), (80, 126), (77, 132), (76, 126)]',)
('trip data: 18 $41 [(-52, 124), (-56, 123), (-53, 126), (-48, 122), (-53, 123), (-49, 126), (-49, 125), (-47, 120)]',)
('trip data: 17 $51 [(-87, 147), (-85, 145), (-84, 150), (-88, 148), (-83, 149), (-85, 148), (-90, 142), (-85, 149), (-86, 151)]',)
('trip data: 3 $75 [(36, 54), (37, 55), (34, 53), (37, 49), (31, 59), (38, 55), (31, 56), (33, 52), (38, 49), (32, 55)]',)
('trip data: 14 $46 [(-8, 100), (-7, 104), (-8, 104), (-6, 100), (-4, 99), (-6, 100), (-5, 104), (-3, 101), (-8, 96), (-9, 103)]',)
('trip data: 19 $56 [(-17, 24), (-18, 20), (-14, 23), (-13, 20), (-19, 25), (-17, 25), (-16, 19), (-17, 22), (-14, 24), (-20, 29)]',)
uber ^python tripgrid/TripQuery.py -a --bl -90,-180 --tr 90,180
python tripgrid/TripQuery.py -a --bl -90,-180 --tr 90,180
Trips:  11 set([1, 2, 3, 4, 6, 8, 9, 10, 16, 18, 19])

hmm, and...we should think about our data struct.  right now with the ordered
set, we can't have duplicates in our tripList, which means we lost an old data
point.

so we just checked the query on two trips, and it's not correct :(, but at least
we see a repro!

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
debugging:

zrange "tripQueue:0:locations" 0 -1
1) "(-18, 142)" -> 4, 8
2) "(-16, 145)" -> 4, 9 (edge)
3) "(-14, 139)" -> 4, 8
4) "(-19, 137)" -> 4, 8
5) "(-21, 142)" -> 3, 8
6) "(-20, 137)" -> 3, 8
7) "(-15, 138)" -> 4, 8
8) "(-16, 144)" -> 4, 9 (edge)

zrange "tripQueue:1:locations" 0 -1
1) "(-19, -172)" 3, 0 (edge)
2) "(-17, -176)" 4, 0 (edge)

ok, so checked these queues, and this is accurate in our grid.  had to fix a couple
of late night incorrect comparisons

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
          0     1     2    3    4  5   6   7    8    9
lat:  [ -90,  -72,  -54, -36, -18, 0, 18, 36,  54,  72]
long: [-180, -144, -108, -72, -36, 0, 36, 72, 108, 144]
                     (7, 9)     (7, 9)     (8, 9)     (7, 9)
('trip data: 1 $25 [(52, 145), (49, 149), (57, 147), (51, 145)]',)

                     (9, 7)     (X, 8)     (X, 7)     (X, 7)     (9, 7)
('trip data: 0 $24 [(88, 104), (91, 108), (93, 107), (92, 107), (83, 103)]',)
                                *           *          *

*these coordinates should not be there!

BUG: bad coordinates inserted: fixed assert on bad location

./startSim.py

                      (4, 9)      (4, 9)      (4, 9)      (3, 9)      (3, 9)      (4, 9)
('trip data: 0 $38 [(-18, 161), (-13, 157), (-13, 162), (-22, 163), (-23, 161), (-14, 159)]',)

                      (4, 1)       (4, 1)       (3, 1)       (4, 1)       (3, 1)       (3, 1)       (4, 1)       (3, 1)       (3, 1)       (4, 1)
('trip data: 1 $57 [(-18, -131), (-17, -126), (-19, -133), (-14, -132), (-22, -130), (-20, -128), (-15, -128), (-19, -128), (-19, -127), (-14, -134)]',)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
from tripgrid.TripCommon import *
locationToGridQueues()
locationsToGridQueues()
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[(5, 3),    (5, 3),   (5, 3),    (5, 3),   (5, 3)]
[(5, -52), (10, -56), (6, -56), (10, -49), (6, -51)]

 [(7, 8),    (7, 8),    (7, 8),    (7, 8),    (7, 8)]
[(39, 132), (39, 133), (37, 137), (43, 137), (43, 132)]

./query
('additional trips added', ['9'])
Trips:  7 [0, 1, 2, 4, 7, 8, 9]

BUG: what happened to: 3 5 6???
-> comparison was against string and not integer value.
-> was comparing y value against l[0], which is the X value
-> wrong interpretation of locations retrieved from zrange:
   LESSON: -> values retrieved from redis are strings and must
   be converted to pythonic use.

BUG: not recording queues with more than 2 IDs:
   query:
     ('trips added for ', 'tripGrid:5:4:ALL', ' ', [])
   redis result:
     redis 127.0.0.1:6379> zrange 'tripGrid:5:4:ALL' 0 -1
     zrange 'tripGrid:5:4:ALL' 0 -1
     1) "7"
     2) "14"

   -> problem was the wrong arguements: -1, 0 instead of 0, -1....

Should also right some tests:
test different quadrants, make sure queries are correct.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Trips:  16 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 16, 18]
missing: 12, 15, 17, 19

12:
1) "(86, -146)" (9,0)
2) "(81, -147)" (9,0)
3) "(89, -151)" (9,0)

>>> r.zrangebyscore("tripGrid:9:0:ALL", "-inf", "inf")
r.zrangebyscore("tripGrid:9:0:ALL", "-inf", "inf")
['12', '19']

hmm, so we need to look at the right edge.

- - - - - - - - - - - - - - -
Sat Dec 21 14:11:19 MST 2013
- - - - - - - - - - - - - - -

nice, so fixed it all up for time slices as well, so we should
start testing!  time slices are working!

- 1 set of tests: one quadrant is all that is used, the other quadrants must be
empty.

- one quadrant has evens and the other has odds.

- only trips on the edges

I really need to setup a test driver

1) clears db
2) sets test quadrant
3) runs simulator
4) runs query and checks for correct answer

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

TODO
DONE 1) set delay to nothing for testdrive

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

for some reason, the join isn't helping to make sure all of the trips have been
recorded.  setting the sleep seems to help it a little, but there's sometimes a
trip missing.  I don't think the problem is with the the join not blocking,
since if I increase the work time, it seems to actually work for longer.

I think the problem is a race condition with the redis sync and the query.

yeah...I'm seeing issues like:

AssertionError: Error, testAllQuadrants reported 11 trips != 10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
AssertionError: Error, testAllQuadrants reported 9 trips != 10: [0, 1, 2, 3, 4, 5, 6, 7, 10]
AssertionError: Error, testOneTrip reported 4 trips != 1

where the first trip's ID is still in there...which is telling me that the redis
commands aren't sequentialized (atomic...transactional?)

ah, actually, there are a couple of problems:

1) Incorrect top-left designation
-     QueryRect((-90, -180), (79, 179), "ALL", "-inf", "inf", False, results)
+     QueryRect((-90, -180), (89, 179), "ALL", "-inf", "inf", False, results)

2) not calling save after the flush() ???
  -> This isn't fixing the problem

3) need to call flushall instead of flushdb
  -> This isn't fixing the problem

Hmm, so I'm flushing and printing out the keys before each test, and its empty,
so there may be some lingering threads.

ok, so the threads do seem to be ending, and the keys (redis db) does seem to be
clear when we query it, so the only other component here is celery and rabbitmq.
could it be delaying the messages?

  sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

some weird reporting error.

1) XXX keys * []
2) ('tripID 0 distance 2',)
3) XXX waited 0.039414 seconds
4) tripID 0: 1 ['(-43, -110)']
5) Error, testOneTrip reported 0 trips != 1: []

in 4, we query all the tripIDs, which shows one trip, so
why does the results['trips']) not show any trips?

- - - - - - - - - - - - - - -
Mon Jan 06 04:54:48 PST 2014
- - - - - - - - - - - - - - -

damn, still got errors:

AssertionError: Error, testAllQuadrants reported 11 trips != 10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
AssertionError: dbsize 6 not equal to zero.

('tripID 1 distance 10',)
('tripID 2 distance 10',)
('tripID 3 distance 6',)
('tripID 4 distance 5',)
('tripID 5 distance 9',)
('tripID 6 distance 3',)
('tripID 7 distance 8',)
('tripID 8 distance 1',)
('tripID 9 distance 1',)
('tripID 10 distance 8',)

XXX waited 0.772486 seconds
tripID 1: 3 ['(63, -133)', '(58, -134)', '(64, -136)']
tripID 2: 2 ['(73, -69)', '(68, -72)']
tripID 3: 2 ['(6, 170)', '(8, 166)']
tripID 4: 2 ['(-64, 149)', '(-61, 152)']
tripID 5: 2 ['(46, -128)', '(44, -133)']
tripID 6: 3 ['(85, 4)', '(89, 2)', '(86, 4)']
tripID 7: 1 ['(68, 176)']
tripID 8: 2 ['(55, -10)', '(54, -12)']
tripID 9: 2 ['(-73, 130)', '(-74, 132)']

Traceback (most recent call last):
  File "./drive.py", line 4, in <module>
    tripgrid.drivetest.main()
  File "/Users/dphung/Dropbox/src/uber/tripgrid/drivetest.py", line 161, in main
    testAllQuadrants()
  File "/Users/dphung/Dropbox/src/uber/tripgrid/drivetest.py", line 71, in testAllQuadrants
    % (len(results['trips']), numTrips, results['trips'])

AssertionError: Error, testAllQuadrants reported 11 trips != 10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

hmmm, no tripID for 10 reported?

well, if we wait 5 seconds between

what is the diff between dbsize and keys?

should check if redis.flushall() is synchronous.  it is not...or at least, the
sleep helps ameliorate that redis assert.  gonna just put the sleep to 30 and
move on for now.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

lat  loc  -90 -> grid 0
lat  loc  -72 -> grid 1
lat  loc  -54 -> grid 2
lat  loc  -36 -> grid 3
lat  loc  -18 -> grid 4
lat  loc    0 -> grid 5
lat  loc   18 -> grid 6
lat  loc   36 -> grid 7
lat  loc   54 -> grid 8
lat  loc   72 -> grid 9

long loc -180 -> grid 0
long loc -144 -> grid 1
long loc -108 -> grid 2
long loc  -72 -> grid 3
long loc  -36 -> grid 4
long loc    0 -> grid 5
long loc   36 -> grid 6
long loc   72 -> grid 7
long loc  108 -> grid 8
long loc  144 -> grid 9


XXX bl[0] 0 -> blX 5, bl[1] 90 -> blY 7
XXX tr[0] 0 -> trX 5, tr[1] 180 -> trY 9

quadrants

           180
            |
            |
            |
            |
-90 - - - - - - - - - - 90
            |
            |
            |
            |
          -180


ok, nice, so now we are unfortunately including the edges in
our queries.  we have to either exclude the edges from the query or
the trip locations.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

nice...ok, all tests pass, time to scale!

